<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>word-content</title>
  <style>
    body,
    .content {
      overflow: hidden;
    }

    .content {
      line-height: 1.5;
    }
  </style>
</head>

<body>
  <div class="content" id="content"></div>
  <script>
    const container = document.getElementById('content')
    const url = new URL(window.location.href)
    const search = new URLSearchParams(url.search)
    const dictId = search.get('dictId')
    const word = search.get('word')

    function setWordData() {
      // 获取文本
      let text = window.parent._getWordData(dictId)
      container.innerHTML = text
    }

    // 获取 iframe 需要的高度
    function getIframeHeight() {
      return container.getBoundingClientRect().height
    }

    // 调用父窗口设置 iframe 大小
    function setIframeHeight() {
      if (window.parent._setIframeHeight) {
        window.parent._setIframeHeight(dictId, getIframeHeight())
      }
    }
    // 响应窗口大小或者 dom 状态改变
    const observer = new MutationObserver(setIframeHeight)

    observer.observe(container, {
      childList: true,
      attributes: true,
      subtree: true
    })

    setWordData()

    // 数据处理
    setTimeout(() => {
      // a 标签元素处理
      const anchorEls = container.querySelectorAll('a')
        ;[].map.call(anchorEls, el => {
          // 词条
          if (el.attributes.href?.value?.startsWith('entry://')) {
            let entry = el.attributes.href.value.replace('entry://', '')
            // 跳转连接不是 # 开头的才可以跳转，以 # 开头的链接属于释义内部跳转，暂不支持
            if (!entry.startsWith('#')) {
              // 修改为可以通过链接打开--主要是为了中键新窗口打开
              el.setAttribute('href', `/search?word=${entry}`)
              // 左键点击事件，触发 clickEntry 事件。屏蔽默认行为。因为页面切换加了动画。左键通过默认行为查询单词效率太低
              el.onclick = (e) => {
                if (window.parent._clickEntry) {
                  window.parent._clickEntry({
                    detail: {
                      entry
                    }
                  })
                }
                e?.preventDefault()
                console.log(entry)
              }
            } else {
              el.setAttribute('href', 'javascript: void(0)')
            }
          }
          // 音频
          if (el.attributes.href?.value?.startsWith('sound://')) {
            let sound = el.attributes.href?.value
            el.setAttribute('href', 'javascript: void(0)')
            el.onclick = () => {
              if (window.parent._clickSound) {
                window.parent._clickSound(dictId, {
                  detail: {
                    sound
                  }
                })
              }
            }
          }
        })
      // 脚本
      const scriptEls = container.querySelectorAll('script')
        ;[].map.call(scriptEls, el => {
          if (el.src) {
            const s = document.createElement('script')
            s.src = el.src
            document.body.appendChild(s)
          }
        })
    }, 0) 
  </script>
</body>

</html>